## 线程

线程被定义为程序的执行路径，每个线程都定义了一个独特的控制流

线程是轻量级的进程，一个使用线程的常见示例是现代操作系统中并行编程的的实现。使用线程节省了CPU周期的浪费，同时提高了程序的运行效率

## 线程生命周期

线程的生命周期开始于 Thread类的对象被创建的瞬间，结束于线程被终止或完成执行时

### 线程生命周期中的各种状态

- 未启动状态：当线程实例被创建，但Start方法为被调用的时候
- 就绪状态：当线程准备好运行，等待CPU周期时的状态
- 不可运行状态：
  - 已经调用sleep方法
  - 已经调用wait方法
  - 通过I/O操作阻塞
- 死亡状态：当前线程已完成或已中止的状态

```csharp
        Thread t = Thread.CurrentThread;//获取当前线程
        t.Name = "MainThread";//设置线程的名字
        Console.WriteLine(t.Name);//输出线程的名字
```

线程中第一个被执行的线程成为主线程

当C#程序开始执行时，主线程自动创建

### ThreadStart()

是一个委托

~~~Csharp
        static void Main(string[] args)
        {
            //ThreadStart start = new ThreadStart(ChildThreadMethod);
            //Thread childThread = new Thread(start);
            Thread childThread = new Thread(new ThreadStart(ChildThreadMethod));
            childThread.Start();//开启线程

            Console.WriteLine("MainThread is running!");
        }

        public static void ChildThreadMethod()
        {
            Console.WriteLine("ChildThread is Running");
        }
~~~

### Thread

也是一个委托 构造函数中可以接收无参或只有一个参的方法作为参数

~~~Csharp
            Thread t = new Thread(
                () => Console.WriteLine("childThread:" + Thread.CurrentThread.ManagedThreadId));
            t.Start();
            Console.WriteLine("mainThread:" + Thread.CurrentThread.ManagedThreadId);
~~~

### 多线程数据传递

#### 1. 利用Start方法传递参数

~~~Csharp
        public struct Books
        {
            public string title;
            public int book_id;
        };

        static void Main(string[] args)
        {
            Books book1 = new Books();
            book1.title = "你好世界";
            book1.book_id = 1;
            Thread t = new Thread(Test);
            t.Start(book1);

            Console.WriteLine("mainThread:" + Thread.CurrentThread.ManagedThreadId);
        }

        public static void Test(Object o)
        {
            Console.WriteLine("childThread started");
            Books book = (Books)o;
            Console.WriteLine(book.title);
            Console.WriteLine(book.book_id);
            Console.WriteLine("childThread completed");
        }
~~~

#### 2. 传递自定义类的成员方法

~~~Csharp
//自定义类
    class DownLoadTool
    {

        public string URL { get; private set; }
        public string Message { get; private set; }

        public DownLoadTool(string uRL, string message)
        {
            URL = uRL;
            Message = message;
        }

        public void DownLoad()
        {
            Console.WriteLine("ChildThread started");
            Console.WriteLine("正在从" + URL + "中下载" + Message);
            Console.WriteLine("ChildThread completed");
        }
    }
~~~

~~~Csharp
    class Program
    {
        static void Main(string[] args)
        {
            DownLoadTool downLoadTool = new DownLoadTool("www.siki.com","thread lesson");
            Thread t = new Thread(downLoadTool.DownLoad);
            t.Start();

            Console.WriteLine("mainThread:" + Thread.CurrentThread.ManagedThreadId);
        }
    }
~~~

## 前后台线程

后台线程：主线程执行完毕后就会关掉的线程

前台线程：主线程需要等待其执行完毕，自己才能执行完毕的线程

## 线程优先级

使用`对象名.Priority = ThreadPriority.线程等级`来设置

线程等级分为 `Highest`  `AboveNormal`  `Normal` `BelowNormal`  `Lowest`

~~~Csharp
        static void Main(string[] args)
        {
            Thread a = new Thread(A);
            a.Priority = ThreadPriority.AboveNormal;
        }

        static void A()
        {
            Console.WriteLine("A");
        }
~~~

控制线程

当调用`Start`方法之后，线程先进入`unstarted`状态 再进入 `running`状态 使用`Thread.Sleep()`方法使线程休眠进入`WaitSleepJoin`状态。

如果需要等待线程结束，可以调用`Thread类`的`Join`方法表示把Thread加入进来,这相当于将其他线程与当前线程合二为一了

## 线程池

创建线程需要事件，如果有很多小任务需要用到线程，就会花费很多时间来创建线程

ThreadPool类：已经创建好了一大堆线程待用

`ThreadPool.QueueUserWorkItem`()方法传入一个有参函数

~~~Csharp
        static void Main(string[] args)
        {
            for (int i = 0; i < 10; i++)
            {
                ThreadPool.QueueUserWorkItem(DownLoad);
            }
            Thread.Sleep(5000);
        }

        static void DownLoad(Object state)
        {
            for (int i = 0; i < 3; i++)
            {
                Console.WriteLine("DownLoading...i= " + i + "threadId= " + Thread.CurrentThread.ManagedThreadId);
            }
        }
~~~

注意：

- 线程池中的所有线程都是后台线程，不能把入池的线程改为前台线程
- 不能给入池的线程设置优先级或名称 